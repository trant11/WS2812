#include "stm8s.h"
#include "milis.h"
#include "delay.h"

#define _ISOC99_SOURCE
#define _GNU_SOURCE

uint8_t red (uint16_t x);
uint8_t green (uint16_t x);
uint8_t blue (uint16_t x);
uint16_t x = 0;
uint8_t colors[32]={0};//array do kterého se zapisuje barvy na urèité LEDce0

uint8_t minule = 0;
int8_t cisloLED = 0; //cislo aktualni LED
void rozsvitLED(uint16_t cisloLED, uint8_t r, uint8_t g,uint8_t b);


void init_spi(void){
    // Software slave managment (disable CS/SS input), BiDirectional-Mode release MISO pin to general purpose
    SPI->CR2 |= SPI_CR2_SSM | SPI_CR2_SSI | SPI_CR2_BDM | SPI_CR2_BDOE;
    // Enable SPI as master at maximum speed (F_MCU/2, there 16/2=8MHz)
    SPI->CR1 |= SPI_CR1_SPE | SPI_CR1_MSTR;
}


#define L_PATTERN 0b01110000    // 3x125ns (8MHZ SPI)
#define H_PATTERN 0b01111100    // 5x125ns (8MHZ SPI), first and last bit must be zero (to remain MOSI in Low between frames/bits)
// takes array of LED_number * 3 bytes (RGB per LED)

void neopixel(uint8_t * data, uint16_t length)
{
    uint8_t mask;
    disableInterrupts();        // can be omitted if interrupts do not take more then about ~25us
    while(length--) {            // for all bytes from input array
        mask = 0b10000000;     // for all bits in byte
        while (mask) {
            while (!(SPI->SR & SPI_SR_TXE));    // wait for empty SPI buffer
            if (mask & data[length]) {  // send pulse with coresponding length ("L" od "H")
                SPI->DR = H_PATTERN;
            } else {
                SPI->DR = L_PATTERN;
            }
            mask = mask >> 1;
        }
    }
    enableInterrupts();
    while (SPI->SR & SPI_SR_BSY); // wait until end of transfer - there should come "reset" (>50us in Low)
}

void delay_ms(uint16_t ms) {
    uint16_t  i;
    for (i=0; i<ms; i = i+1){
        _delay_us(250);
        _delay_us(248);
        _delay_us(250);
        _delay_us(250);
    }
}


/*// test pattern for (8 RGB LED ring)
uint8_t colors[32] = {
    0, 0, 0,            // 
    0, 0, 0,           // B
    0, 0, 0,     // R
    0, 0, 0,           // G
    0, 0, 0,           // black
    0, 0, 0,           // light white
    0, 0, 0,            // light white
    10, 0, 0,           // B
    10, 0, 0,           // B
    10, 0, 0 ,        // B
    10, 0, 0
};
*/


int main(void){
    CLK_HSIPrescalerConfig(CLK_PRESCALER_HSIDIV1);
    init_spi();

        neopixel(colors, sizeof(colors));
        delay_ms(2);


    while (1) {
        
    if(GPIO_ReadInputPin(GPIOE,GPIO_PIN_4) == RESET && minule == 1){//na tlacitko rozsviti nasledujici LED "vìtší" barvou podle spektra barev
                minule = 0;
                rozsvitLED(cisloLED, red(x),green(x), blue(x));               
                 cisloLED++;
                if (x<254){//dokud neni x nejvesti barva zvetsuje barvu - na konci spektra je jen cervena
                x = x+8;//pricte barvu
                }
                if (cisloLED>=8){//pocet LEDek na ringu
                cisloLED = 0;
                }
    }
    
        if(GPIO_ReadInputPin(GPIOE,GPIO_PIN_4) != RESET){
        minule = 1;
		}
/*
    void rozsvitLED(uint16_t cisloLED, uint8_t r, uint8_t g,uint8_t b){ //0-23
	uint16_t x = cisloLED*3; //každá LED ma 3 bajty proto krát3
	colors[x] = b; //do array colors na pozici x pøipišu barvu, teï modrou která je v tuto chvíli 0, svítím jen èervenì
	x++;
	colors[x] = r;
	x++;
	colors[x] = g;
	neopixel(colors, sizeof(colors)); // pošlu array "colors" do led ringu
	delay_ms(2);
}
*/
        //colors[1]++;

}
}